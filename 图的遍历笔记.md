# 图的遍历笔记

## 手搓邻接表及输入

邻接表的概念见Dijkstra算法笔记

手搓程序如下:

```
#define MVNum 100//maxvertexnumber
typedef struct ArcNode//这里重点应该是节点而不是边,因为表示节点指向的节点,下文要记住
{
    int adjvex;//存这条边指向的顶点的索引,索引是对于下面的vertices数组说的
    struct ArcNode* nextarc;//在邻接表的数组拉开成表
    //OtherInfo info;这里可以是权
}ArcNode;
typedef struct VNode
{
    char data;//该类取决于想在节点存什么类型的数据
    ArcNode* firstarc;
}VNode,AdjList[MVNum];//
typedef struct//这叫匿名结构体,只有别名
{
    AdjList vertices;//这是定义了一个数组,存VNode,VNode存边表示哪些顶点指向它
    int vexnum,arcnum;
}ALGraph;
//typedef和struct在一起很混乱 下面给出struct定义类 typedef单行定义别名的
#define MVNum 100
struct ArcNode
{
    int adjvex;
    struct ArcNode* nextarc;
    //OtherInfo info;
};
//typedef struct ArcNode ArcNode;C++11后允许直接使用结构体类型名而不用额外添加struct关键字,下同
struct VNode
{
    char data;
    ArcNode* firstarc;
};
//typedef struct VNode VNode;
typedef struct VNode AdjList[MVNum];
struct Graph
{
    AdjList vertices;
    int vexnum,arcnum;
};
typedef struct Graph ALGraph;
/*
总结:struct的名字紧邻struct关键字 struct右括号后分号前是别名(如果含typedef) 双重名字是旧标准
补充直接初始化变量型(这种情况是在结构体定义后加一个空格):
struct MyStruct
{
    int information;
} MyVar={1};
不过不允许如下:
typedef struct MyStruct
{
    int information;
}MyStruct,OtherName MyVar={1};
因为typedef和变量定义不能同时进行
*/
void CreateG(ALGraph &G)
{
    cin>>G.vexnum>>G.arcnum;
    for(int i=0;i<G.vexnum;++i)
    {
        cin>>G.vertices[i].data;
        G.vertices[i].firstarc=NULL;
    }
    for(int k=0;k<G.arcnum;++k)
    {
        char v1,v2;
        cin>>v1>>v2;
        int i=LocateVex(G,v1);
        int j=LocateVex(G,v2);
        ArcNode* p1=new ArcNode;
        p1->adjvex=j;
        p1->nextarc=G.vertices[i].firstarc;
        G.vertices[i].firstarc=p1;
    }
    return;
}
int LocateVex(ALGraph &G,char a)
{
    int index=-1;
    for(int i=0;i<G.vexnum;++i)
    {
        if(G.vertices[i].data==a)
        {
            index=i;
        }
    }
    return index;
}
```

## 深度优先搜索(Depth First Search,DFS)、广度优先搜索(Breadth First Search,BFS)

### DFS

DFS类似树的先序遍历,为其推广,对于一个简单连通图,DFS过程如下:

1.从图中某个顶点v出发并访问其

2.找出刚访问过的顶点的第一个未被访问的邻接点,访问该顶点,以该顶点为新顶点,重复此步骤,直至刚访问过的顶点没有未被访问的邻接点为止

3.返回前一个访问过的且仍有未被访问的邻接点的顶点,找出该顶点下一个未被访问的邻接点,访问该顶点

4.重复2、3,直至图中所有顶点都被访问过

程序如下:

```
bool visited[MVNum]={0};//辅助数组表示该顶点是否被访问,其索引和邻接表中vertices的顶点索引对应或者邻接矩阵中vexs索引对应
void DFS_AM(AMGraph G,int v)//基于手搓邻接矩阵,见Prim算法笔记
{
    cout<<v;//输出下标不是顶点数据,按需修改
    visited[v]=true;
    for(int w=0;w<G.vexnum;++w)
    {
        if((G.arcs[v][w])!=0&&(!visited[w]))
        {
            DFS_AM(G,w);
        }
    }
}
void DFS_AL(ALGraph G,int v)
{
    cout<<v;
    visited[v]=true;
    ArcNode* p=G.vertices[v].firstarc;
    while(p!=NULL)
    {
        int w=p->adjvex;
        if(!visited[w])
        {
            DFS_AL(G,w);
        }
        p=p->nextarc;
    }
}
```

### BFS

BFS类似树的层次遍历,过程如下:

1.从图中某个顶点v出发,访问v

2.依次访问v的各个未曾访问过的邻接点

3.分别从这些邻接点出发依次访问它们的邻接点,并使"先被访问的顶点的邻接点"先于"后被访问的顶点的邻接点"被访问,重复步骤3,直至图中所有已被访问的顶点的邻接点都被访问到,程序如下

基于邻接表:

```
typedef struct
{
    int* base;
    int front;
    int rear;
}SqQueue;
void InitQueue(SqQueue &Q)
{
    Q.base=new int[MAXQSIZE];//数组存VNode的索引
    Q.front=Q.rear=0;
    return;
}
int QueueLength(SqQueue Q)
{
    return (Q.rear-Q.front+MAXQSIZE)%MAXQSIZE;
}
void EnQueue(SqQueue &Q,int e)
{
    Q.base[Q.rear]=e;
    Q.rear=(Q.rear+1)%MAXQSIZE;
    return;
}
void DeQueue(SqQueue &Q,int &e)
{
    e=Q.base[Q.front];
    Q.front=(Q.front+1)%MAXQSIZE;
    return;
}
int GetHead(SqQueue Q)
{
    return Q.base[Q.front];
}
bool QueueEmpty(SqQueue Q)
{
    if(Q.front==Q.rear)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}
void BFS(ALGraph G,int v)
{
    cout<<v;
    visited[v]=true;
    SqQueue Q;
    InitQueue(Q);
    EnQueue(Q,v);
    while(!QueueEmpty(Q))
    {
        int u;
        DeQueue(Q,u);
        for(int w=FirstAdjVex(G,u);w>=0;w=NextAdjVex(G,u,w))//获取u相对于w的下一个邻接点,u是数组节点,w才是遍历的,这是w的一个迭代更新,Next函数逻辑和w在这里的赋值没关系,其只需查找u的下一个邻接点(对于w)就行了
        {
            if(!visited[w])
            {
                cout<<w;
                visited[w]=true;
                EnQueue(Q,w);
            }
        }
    }
}
int FirstAdjVex(ALGraph G,int index)//节点数组index位置的节点指向的第一个节点
{
    return G.vertices[index].firstarc->adjvex;
}
int NextAdjVex(ALGraph G,int index1,int index2)
{
    ArcNode* p = G.vertices[index1].firstarc;//临时指针等于数组节点的第一个指向的节点
    while(p->adjvex != index2)//当节点不等于w
    {
        p = p->nextarc;//则前移节点
    }
    return p->nextarc->adjvex;//已经前移到等于w,获取w的下一个节点
}
```

基于邻接矩阵:

```
typedef struct
{
    int* base;
    int front;
    int rear;
}SqQueue;
void InitQueue(SqQueue &Q)
{
    Q.base=new int[MAXQSIZE];//数组存vexs的索引
    Q.front=Q.rear=0;
    return;
}
int QueueLength(SqQueue Q)
{
    return (Q.rear-Q.front+MAXQSIZE)%MAXQSIZE;
}
void EnQueue(SqQueue &Q,int e)
{
    Q.base[Q.rear]=e;
    Q.rear=(Q.rear+1)%MAXQSIZE;
    return;
}
void DeQueue(SqQueue &Q,int &e)
{
    e=Q.base[Q.front];
    Q.front=(Q.front+1)%MAXQSIZE;
    return;
}
int GetHead(SqQueue Q)
{
    return Q.base[Q.front];
}
bool QueueEmpty(SqQueue Q)
{
    if(Q.front==Q.rear)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}
void BFS(AMGraph G,int v)
{
    cout<<v;
    visited[v]=true;
    SqQueue Q;
    InitQueue(Q);
    EnQueue(Q,v);
    while(!QueueEmpty(Q))
    {
        int u;
        DeQueue(Q,u);
        for(int w=FirstAdjVex(G,u);w>=0;w=NextAdjVex(G,u,w))
        {
            if(!visited[w])
            {
                cout<<w;
                visited[w]=true;
                EnQueue(Q,w);
            }
        }
    }
}
int FirstAdjVex(AMGraph G,int index)//节点数组index位置的节点指向的第一个节点
{
    for(int i=0;i<G.vexnum;++i)
    {
        if(G.arcs[index][i]!=0)
        {
            return i;
        }
    }
}
int NextAdjVex(AMGraph G, int u, int w)
{
    for(int i = w + 1; i < G.vexnum; ++i)
    {
        if(G.arcs[u][i] != 0)
        {
            return i;
        }
    }
}
```