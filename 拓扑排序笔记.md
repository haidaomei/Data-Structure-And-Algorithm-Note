# 拓扑排序笔记

## 术语

DAG图:有向无环图(Directed Acycline Graph)

AOV网:用顶点表示活动,用弧(边)表示活动间优先关系的有向图称为"以顶点表示活动的网(Activity on Vertex Network)"

拓扑排序:将AOV网中所有顶点排成一个线性序列,该序列满足若在AOV网中从顶点a到顶点b有一条路径,则该线性序列中的顶点a必定在顶点b之前

另一种角度理解拓扑排序:DAG图和AOV网用顶点表示活动,被指向的顶点的活动依赖指向其的顶点的先行活动,如果没有后者在前,前者无法进行,拓扑排序输出的序列表示了一种活动的优先关系(不被指向的顶点表示无依赖)

## 过程(Kahn算法)

拓扑排序的过程如下:

1.在有向图中选一个无前驱的节点且输出它

2.从图中删除该顶点和所有以它为尾的弧(边)

3.重复1、2,直至不存在无前驱的顶点

4.若此时输出的顶点数小于有向图中的顶点数,则说明有向图中存在环,否则输出的顶点序列即一个拓扑序列

实现:

```
#define MVNum 100
struct ArcNode
{
    int adjvex;
    struct ArcNode* nextarc;
    //OtherInfo info;
};
struct VNode
{
    char data;
    ArcNode* firstarc;
};
typedef VNode AdjList[MVNum];
struct Graph
{
    AdjList vertices;
    int vexnum,arcnum;
};
typedef struct Graph ALGraph;//以上基于cpp11标准,允许直接使用结构体名作为类
#define MAXSIZE 100
struct SqStack
{
    int* base;
    int* top;//指针类型取决于要存什么,由于下面存索引,所以这里是int*
    int stacksize;
};
void InitStack(SqStack &S)
{
    S.base=new int[MAXSIZE];
    S.top=S.base;//上不做错误处理(存储分配失败情况)
    S.stacksize=MAXSIZE;
    return;
}
void Push(SqStack &S,int e)
{
    *S.top=e;
    S.top++;//等同于*S.top++=e;
    return;//上不做栈溢出处理,但条件判断在理解中同样重要,下同
}
void Pop(SqStack &S,int &e)
{
    --S.top;
    e=*S.top;
    return;
}
int GetTop(SqStack S)
{
    return *(S.top-1);
}
bool StackEmpty(SqStack S)
{
    return S.top==S.base;
}
void FindInDegree(ALGraph G,int array[])
{
    for(int i=0;i<G.vexnum;++i)
    {
        ArcNode* p=G.vertices[i].firstarc;
        while(p!=NULL)
        {
            array[p->adjvex]=array[p->adjvex]+1;
            p=p->nextarc;
        }
    }//想法:遍历整个邻接表,arcnode存边必指向某点
}
int TopologicalSort(ALGraph G,int topo[])
{
    int indegree[G.vexnum]={0};//存放各顶点入度,运行时确定内存分配,c99标准后支持,cpp标准从未支持,但编译器有优化
    FindInDegree(G,indegree);//求解各顶点入度
    SqStack S;
    InitStack(S);
    for(int i=0;i<G.vexnum;++i)
    {
        if(!indegree[i])
        {
            Push(S,i);
        }
    }//通过顶点入度来分析顶点是不是有依赖,如果顶点无依赖则入栈
    int m=0;//统计出了多少个点
    while(!StackEmpty(S))
    {
        int i;
        Pop(S,i);
        topo[m]=i;
        ++m;//pop一个,统计点+1
        ArcNode* p=G.vertices[i].firstarc;//对于已被pop的点i的每个邻接点
        while(p!=NULL)
        {
            int k=p->adjvex;
            --indegree[k];//使该邻接点入度-1
            if(indegree[k]==0)
            {
                Push(S,k);//若度0则入栈
            }
            p=p->nextarc;//迭代
        }
    }//对已经出栈的一点i,用邻接表遍历一个拉链的方法使其所有指向的点的入度-1,如果度已经0则入栈
    if(m<G.vexnum)//有无环判断
    {
        return -1;
    }
    else
    {
        return 1;
    }
}
```

输出的顶点数小于有向图中的顶点数,则说明有向图中存在环的讨论:

按照上文程序,输出的顶点数=出栈顶点数,这里将一个环变换成一个线性序列,最简的例子如A->B应该输出两个,A->B->A(有环)应该输出零个,但这里会输出三个,直接认证了有环则输出顶点数(出栈顶点数)应该小于图中顶点数