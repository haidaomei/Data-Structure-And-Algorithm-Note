# 哈夫曼树笔记

## 实现

哈夫曼树又称最优树,其带权路径长度最短(即如果树叶有权,那么树根到该树叶的边数(注意边没有权)乘以权,一棵树的这些项总和称为带权路径长度)

由上述概念可发现,哈夫曼树要求权最小的节点为最深的叶(所在深度等于二叉树深度),权最大的节点为最浅的叶(所在深度等于2),叶通过权由上到下递减,这样可满足小权乘以长边,大权乘以短边,所得带权路径长度最短(数学上可以发现大\*大+小\*小一般大于大\*小+小\*大)

哈夫曼树的构建过程:

初态:将给定的n个权值对应的结点,每个都视为一棵独立的二叉树(即只有一个根结点的树),这些树构成一个森林(二叉树的集合),每棵树的权值即其根结点的权值

选择:在当前森林中,找出两棵根结点权值最小的树,如果有多棵权值相同,可任选

创建父结点:创建一个新的根结点,这个新结点的权值等于它两个孩子的权值之和

连接:将上一步选出的两棵树,分别作为这个新结点的左、右子树,左右子树谁权值大没有要求

更新森林:将合并后的这棵新树加入到森林中,同时移除刚才用作孩子的那两棵旧树,至此,森林中的树的数量减少了一棵

循环:将上述步骤重复n-1遍,森林中仅剩下一棵树,得到最终哈夫曼树

哈夫曼树采用数组存储,每个节点除了存数据还存储parent的索引(这不同于大根堆或小根堆(优先队列),由于其为完全二叉树,所以用索引可以直接计算parent和child)

程序:

```
typedef struct
{
    int weight;
    int parent,lchild,rchild;
}HTNode,*HuffmanTree;
void CreateHuffmanTree(HuffmanTree &HT,int n)//n个叶节点
{
    if(n<=1)
    {
        return;
    }
    int m=n*2-1;//2n-1个二叉树节点
    HT=new HTNode[m+1];//不用index=0单元,这是人邮社数据结构第二版给出的,前n个节点用来存储叶节点,后n-1个节点用来存储合成节点
    for(int i=1;i<=m;++i)
    {
        HT[i].parent=0;
        HT[i].lchild=0;
        HT[i].rchild=0;
    }//初始化,注意是对整个数组
    for(int i=1;i<=n;++i)
    {
        cin>>HT[i].weight;
    }//输入权,注意是对n个元素
    for(int i=n+1;i<=m;++i)//i从n+1开始,说明前n个叶节点不参与
    {
        Selete(HT,i-1,s1,s2);//Selete函数的意思是从1开始到i-1结束查找,而不是从1开始到n结束查找,也不是从n开始到i-1结束查找,具体到数组是以1为底搜索范围向右递增,不是静止在1到n,也不是以n为底搜索范围向右递增
        HT[s1].parent=i;
        HT[s2].parent=i;//设置parent=0相当于从森林里删除了节点,因为上面只会对parent为0的节点进行筛选,所以不会选择到这些被合并的节点
        HT[i].lchild=s1;
        HT[i].rchild=s2;
        HT[i].weight=HT[s1].weight+HT[s2].weight;
    }
}
void Selete(HuffmanTree HT, int end, int &s1, int &s2)
{
    //找第一个最小值
    int min1 = 0;
    for (int j = 1; j <= end; ++j)
    {
        if (HT[j].parent == 0)
        {//只考虑未被合并的节点
            if (min1 == 0 || HT[j].weight < HT[min1].weight)
            {
                min1 = j;
            }
        }
    }
    
    //找第二个最小值
    int min2 = 0;
    for (int j = 1; j <= end; ++j)
    {
        if (HT[j].parent == 0 && j != min1)
        {//排除min1
            if (min2 == 0 || HT[j].weight < HT[min2].weight)
            {
                min2 = j;
            }
        }
    }
    s1 = min1;
    s2 = min2;//反过来s1=min2也行,这就是上面左右子树谁权值大没有要求的体现
}
```

上述查找和选择的时间复杂度为二次阶,称为朴素构建,使用优先队列(大根堆小根堆)每次selete都pop出最小节点可以把时间优化到对数阶,具体是把哈夫曼树的存储设计成优先队列(基于weight大小的),但同时保留数组的parent,因为后续要通过子节点追溯parent;此时该数列可被解释成两棵树,一棵是优先队列的完全二叉树,一棵是非优先队列的哈夫曼树;同时,含parent索引的树的数组表示对于哪个节点前哪个节点后是没有要求的,比较weight的优先队列的引入可能会使该数组不符合朴素构建的结果,但不影响后续使用parent追溯,只有当该数组被顺序遍历,并严格要求顺序遍历结果不改变,优先队列才不能被引入,具体实现略

## 应用

等长二进制编码:对于每个字符采用同等长度的二进制码编码(即用一个唯一的二进制码映射到字符)

不等长二进制编码:对于每个字符采用不同长度的二进制码编码

前缀编码:在一个编码方案中,任一个编码都不是其他任何编码的前缀,则称编码是前缀编码

哈夫曼树可以用于二进制编码:由于权值最小的叶节点深,权值最大的叶节点浅,对应到字符上,如果在一段字段里出现的字符少,那么其权低,反之则高,对于高权采用短二进制编码,低权采用长二进制编码,此时二进制编码形式可以对应到二叉树的边,从根向左寻一个节点编0,向右寻一个节点编1,寻到叶子即为叶子的字符对应的二进制编码,可以降低总字段的二进制编码长度,称之为压缩

由于哈夫曼树是一种二叉树任何字符的编码路径都不会是另一字符编码路径的中间节点,即不会中途到达另一个叶节点,这意味着没有一个编码会是另一个编码的前缀,从而避免了解码时的歧义,所以以哈夫曼树编码的方案是前缀编码,解码时无需分隔符即可准确识别每个字符

```
typedef char **HuffmanCode;
void CreateHuffmanCode(HuffmanTree HT,HuffmanCode &HC,int n)//接受哈夫曼树HT和节点数n,生成哈夫曼编码HC,HC的结构是一个数组,每个元素存一个串,所以是**HuffmanCode
{
    HC=new char*[n+1];//开辟数组,依旧1-based
    char* cd=new char[n];//开辟串,最长不超过n
    cd[n-1]=0;//串的终止
    for(int i=1;i<=n;++i)//遍历每个叶子
    {
        int start=n-1;//串的开始输入地点,由于下面从叶子开始向上追溯,所以写编码从尾到头写
        int c=i;//当前节点索引
        int f=HT[i].parent;//当前节点的parent索引
        while(f!=0)//从叶子节点向上回溯到根节点(根节点的parent为0)
        {
            --start;//索引向前移动,放二进制编码字符,进入循环一次移动一遍
            if(HT[f].lchild==c)//判断当前节点是父节点的左孩子还是右孩子
            {
                cd[start]='0';
            }
            else
            {
                cd[start]='1';
            }
            c=f;
            f=HT[f].parent;//向上移动一层:当前节点c变为父节点,上一个父节点变为现在c的父节点
        }
        HC[i]=new char[n-start];
        strcpy(HC[i],&cd[start]);//把串移动到HC去,上面用cd存前面全是空的,移到HC让HC的大小刚好适配这个串
    }
    delete cd;
}
```