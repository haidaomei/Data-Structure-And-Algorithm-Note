# 二叉树的遍历笔记

## 二叉链表

一个节点内有两个指针,分别指向左子节点和右子节点,这种链表结构称为二叉链表(子节点没有指向parent节点的指针),程序如下

```
typedef struct BiTNode
{
    char data;//该类取决于想在该节点存什么类
    struct BiTNode *lchild,*rchild;
}BiTNode,*BiTree;
```

## 基于节点亲子关系的遍历

树的遍历指按某条搜索路径巡访树中每个节点,使得每个节点均被而且仅被访问一次,访问可以说对节点进行各种处理,包括输出节点信息,对节点进行运算和修改

二叉树由三个基本单元组成:根、左子树、右子树,若能依次遍历这三个部分,便遍历了整个二叉树。限定二叉树的遍历先左子树,后右子树,则有三种情况:先序遍历、中序遍历、后序遍历

先序遍历:访问根节点、先序遍历左子树、先序遍历右子树(根左右)

中序遍历:中序遍历左子树、访问根节点、中序遍历右子树(左根右)

后序遍历:后序遍历左子树、后序遍历右子树、访问根节点(左右根)

程序如下:

```
void PreOrderTraverse(BiTree T)
{
    if(T)
    {
        cout<<T->data;
        PostOrderTraverse(T->lchild);
        PostOrderTraverse(T->rchild);//这里注意别写成In和Post,下面也一样
    }
}
void InOrderTraverse(BiTree T)//中序遍历
{
    if(T)
    {
        InOrderTraverse(T->lchild);
        cout<<T->data;
        InOrderTraverse(T->rchild);
    }
}
void PostOrderTraverse(BiTree T)
{
    if(T)
    {
        PostOrderTraverse(T->lchild);
        PostOrderTraverse(T->rchild);
        cout<<T->data;
    }
}
```

调试一遍可看出遍历过程

## 根据遍历序列确定二叉树

如果给出一棵提前被他人封装好的二叉树,可以用上面的方式处理,但如果需要自己输入,则可以使用先序遍历序列确定二叉树,程序如下

```
void CreateBiTree(BiTree &T)
{
    cin>>ch;
    if(ch=='#')
    {
        T=NULL;//输入#则表示接下来为空子树
    }
    else
    {
        T=new BiTNode;
        T->data=ch;
        CreateBiTree(T->lchild);
        CreateBiTree(T->rchild);
    }
}
```

## 层次遍历

层次遍历(Level Order Traverse),指从二叉树的根节点(第一层)开始,自上而下、从左到右地逐层访问所有节点

为了实现这种顺序,算法通常借助一个队列作为辅助数据结构，其核心过程如下：

初始化:将根节点放入队列

循环执行以下步骤,直到队列为空:

1.从队列头部取出一个节点并访问它

2.如果该节点有左孩子,则将左孩子放入队列尾部

3.如果该节点有右孩子,则将右孩子放入队列尾部

(注意:左右孩子入队必须遵循"先左后右"的顺序,以保证同层节点从左到右的正确访问次序)

程序如下:

```
#define MAXQSIZE 100
typedef struct
{
    BiTNode** base;//该类取决于想在该节点存什么类,这里指存储BiTNode*的数组
    int front;
    int rear;
}SqQueue;
void InitQueue(SqQueue &Q)
{
    Q.base=new BiTNode*[MAXQSIZE];//为简洁,下不作错误处理,不返回状态,下面操作同,不过错误状态判断同样重要,见人邮社数据结构第二版P69-71
    Q.front=Q.rear=0;
    return;
}
int QueueLength(SqQueue Q)
{
    return (Q.rear-Q.front+MAXQSIZE)%MAXQSIZE;
}
void EnQueue(SqQueue &Q,BiTNode* e)
{
    Q.base[Q.rear]=e;
    Q.rear=(Q.rear+1)%MAXQSIZE;
    return;
}
void DeQueue(SqQueue &Q,BiTNode* &e)
{
    e=Q.base[Q.front];
    Q.front=(Q.front+1)%MAXQSIZE;
    return;
}
BiTNode* GetHead(SqQueue Q)
{
    return Q.base[Q.front];
}
//以上手搓循环队列
void LevelOrderTraverse(BiTree &T)
{
    if (T == NULL)
    {
        return;
    }
    SqQueue Q;
    InitQueue(Q);
    BiTNode* current;
    EnQueue(Q, T);
    //当队列不为空时继续遍历
    while (QueueLength(Q) > 0)
    {
        //队首节点出队
        DeQueue(Q, current);
        //访问当前节点（这里以打印节点值为例，实际应用中可根据需求修改）
        cout<<current->data;
        //将当前节点的左孩子入队(如果存在)
        if (current->lchild != NULL)
        {
            EnQueue(Q, current->lchild);
        }
        //将当前节点的右孩子入队(如果存在)
        if (current->rchild != NULL)
        {
            EnQueue(Q, current->rchild);
        }
    }
}
```