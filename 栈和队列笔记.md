# 栈和队列笔记

## 栈

栈是一种后进先出(Last In First Out,LIFO)的结构,规定base指针指向栈底,top指针指向栈顶下一个单位,程序如下

```
#define MAXSIZE 100
typedef struct//匿名结构体,c11标准允许,cpp标准一直不允许
{
    int* base;
    int* top;
    int stacksize;
}SqStack;
void InitStack(SqStack &S)//顺带一提,引用是cpp专有
{
    S.base=new int[MAXSIZE];
    S.top=S.base;//上不做内存分配失败处理
    S.stacksize=MAXSIZE;
    return;
}
void Push(SqStack &S,int e)
{
    *S.top=e;
    ++S.top;
    return;
}
void Pop(SqStack &S,int &e)
{
    --S.top;
    e=*S.top;
    return;
}
int GetTop(SqStack S)
{
    return *(S.top-1);
}
bool IsStackEmpty(SqStack S)
{
    return S.top==S.base;
}
bool IsStackFull(SqStack S)
{
    return S.top-S.base==S.stacksize;
}
```

## 队列

队列是一种先进先出的结构,规定front索引指向队首,rear索引指向队尾下一个单位,程序如下

```
#define MAXQSIZE 100
typedef struct
{
    int* base;
    int front;
    int rear;
}SqQueue;
void InitQueue(SqQueue &Q)
{
    Q.base=new int[MAXQSIZE];
    Q.front=Q.rear=0;//上不做错误处理,结构体不能直接初始化成员,所以得在这里
    return;
}
int QueueLength(SqQueue &Q)
{
    return (Q.rear-Q.front+MAXQSIZE)%MAXQSIZE;
}
void EnQueue(SqQueue &Q,int e)
{
    Q.base[Q.rear]=e;
    Q.rear=(Q.rear+1)%MAXQSIZE;
    return;
}
void DeQueue(SqQueue &Q,int &e)
{
    e=Q.base[Q.front];
    Q.front=(Q.front+1)%MAXQSIZE;
    return;
}
int GetHead(SqQueue Q)
{
    return Q.base[Q.front];
}
bool IsQueueEmpty(SqQueue Q)
{
    return !(Q.rear-Q.front);
}
bool IsQueueFull(SqQueue Q)
{
    return (Q.rear+1)%MAXQSIZE==Q.front;
}
```


循环队列记忆方法:队首为front在低地址,队尾为rear在高地址,出入队都用二者索引,出入队索引就加一取模服从循环,队空是索引相同这是规定,队长是rear-front+size再取模循环,队满是rear+1取模循环等于front,后两者注意区别,队长是做差,队满是比较
