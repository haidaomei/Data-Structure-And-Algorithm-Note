# 快速排序笔记

## 定义

快速排序是一种排序算法,采用分治和递归方法实现

## 过程

一般选择线性表第一个元素作为基准元素,将第一个元素之后的线性表均分为两部分,第一部分选择最左元素(cpp内索引1),第二部分选择最右元素(cpp内索引size()-1),然后第一部分从左到右,第二部分从右到左遍历,如果左边元素大于右边元素则swap(如果从大到小排序则反之),此时左边所有元素≤基准,右边所有元素≥基准,之后将第一个元素移到第一和第二部分中间,再递归地对两边元素排序即可

快速排序还有不同的分区法,人邮社数据结构第二版给出的是挖坑法,具体为把数组index=0位空置,以1-based的数组的首位移到0索引处,双指针指向1-based索引的头和尾,若指针指向空位则不移动,反之向数组中间移动,右指针遇到小于index=0位元素的元素则swap空位和该指针指向元素,左指针遇到大于等于index=0位元素则swap空位和该指针指向元素,当左右指针相遇说明二者来到空位,此时把index=0位元素移到该位可完成一次分区过程

## 实现(双指针移动法,非挖坑法)

cpp函数:

```
void QuickSort(vector<int>& arr, int left, int right)
{
    if (left >= right)
    {
        return;//简单输入错误处理
    }
    int pivot = arr[left];//选择第一个元素作为基准
    int i = left + 1;
    int j = right;
    while (i <= j)
    {
        //从左找大于基准的，从右找小于等于基准的
        if (arr[i] <= pivot)//这里和下面的if可以改成while,区别在于一个大循环移动移动一次指针还是多次,没有算法结果上的区别
        {
            i++;
        }
        else if (arr[j] > pivot)
        {
            j--;
        }
        else
        {
            //交换不满足条件的两个元素
            swap(arr[i], arr[j]);
        }
    }
    //将基准放到正确位置
    swap(arr[left], arr[j]);
    //递归排序左右部分
    QuickSort(arr, left, j - 1);
    QuickSort(arr, j + 1, right);
}
```

## 分析

平均时间复杂度:$O(n\log n)$

最坏时间复杂度:$O(n^2)$(当数组已排序时)

空间复杂度:$O(\log n)$(递归调用栈)

稳定性(如果两个元素的值相等,排序后它们的相对顺序保持不变的属性,不稳定排序一般不用于附带lambda表达式的排序,即对结构体/类内成员的顺序对整个结构体/类集合排序):不稳定

## 相关证明

在算法分析中,当一个算法中包含递归调用时,其时间复杂度的分析可以转化为一个递归方程求解(数据结构 C语言版 第2版 人民邮电出版社 P65)

根据书中内容,模仿阶乘递归函数$T(n)=T(n-1)+C$,其中$T(n)$为语句频度(数据结构 C语言版 第2版 人民邮电出版社 P12),$n$为第一次在main函数调用函数的参数规模,$n-1$为第一次递归的参数规模,对该式进行$n-1$次展开(到递归停止条件$n=0$)可得$T(n)=Cn+T(0)$,可得
    
最优时间复杂度:每次选择的基准都能将数组均匀分成两半,$T(n)_{best}=2T(n/2)+C$,对该式进行$\log_2n$次展开可得$T(n)_{best}=T(1)n+Cn\log_2n$

最坏时间复杂度:每次选择的基准都是最小或最大元素,$T(n)_{worst}=T(n-1)+Cn$,对该式进行$n-1$次展开可得$T(n)_{worst}=T(1)+C\sum_{i=2}^ni=T(1)+C[n(n+1)/2-1]$

平均时间复杂度:暂时不会,涉及概率论

对于递归算法,空间复杂度的自变量为递归工作栈中工作记录的个数与问题规模n的函数关系(数据结构 C语言版 第2版 人民邮电出版社 P65)

现可简单理解为空间复杂度和两个变量有关:递归深度(一定和问题规模相关),额外分配空间(可能和问题规模相关),由于在main函数调用该函数和递归时没有额外空间开销,所以快速排序的空间复杂度只和递归深度相关(区别于归并排序和二者都相关)

最优空间复杂度:由最优时间复杂度得递归深度为$\log_2n$,故最优空间复杂度为$O(\log n)$

最坏空间复杂度:由最坏时间复杂度得递归深度为$n-1$,故最坏空间复杂度为$O(n)$

平均空间复杂度:暂时不会,涉及概率论

不稳定性:不稳定的根源在于快速排序的核心操作:分区,在分区过程中,元素会被交换到基准值的两侧,而这个交换是"跳跃"的,不像冒泡那样相邻元素交换,可能会打乱相等元素的顺序,可以实践进行;只进行相邻元素的比较和移动,并且在元素相等时保持原样不交换,才是稳定(据此也可以把冒泡改为不稳定的);至于证明,证明不稳定性可以只需要反例,证明稳定性涉及数学归纳法,暂时不会

